import geometry
import quadrature
import numpy as np
import matplotlib.pyplot as plt
import math


class Solver(object):

    def __init__(self, geometry):

        self.geometry = geometry
        self.quadrature = quadrature.LevelSymmetricQuadrature()
        self.fuel_total_xs = 100.
        self.moderator_total_xs = 0.25


    def generateQuadratureSet(self):

        self.quad_set = self.quadrature.getQuadratureSet(self.order)
        self.na = self.quad_set['num angles per octant']
        self.wgt = 
            self.quad_set['weight'].reshape(np.newaxis,np.newaxis, np.newaxis,:)


    def initializeMeshCellSources(self):

        mesh_cell_area = self.geometry.getMeshCellArea()
        self.source = self.mesh_stencil / (4. * math.pi * mesh_cell_area)


    def initializeMeshCellXSData(self):

        # Initialize arrays for the homogenized mesh cell cross-section data
        self.total_xs = self.mesh_stencil * self.fuel_total_xs
        self.total_xs += (1.0 - self.mesh_stencil) * self.moderator_total_xs


    def initializeAngularFluxes(self):

        # Indices: cell edge(0 - left, 1 - bottom, etc), mesh index, angle
        self.wave = np.zeros((4, self.num_mesh, self.na))

        # Indices: quadrant, x, y, angle
        self.ang_flux = np.zeros((4, self.num_mesh, self.num_mesh, self.na*4))


    def initializeScalarFluxes(self):

        self.scalar_flux = numpy.zeros((num_mesh, num_mesh))
        self.old_scalar_flux = numpy.ones((num_mesh, num_mesh))


    def convergeScalarFlux(self, num_mesh=15, order=4, max_iters=250, tol=1E-3):
        
        self.num_mesh = num_mesh
        self.mesh = np.arange(self.num_mesh)

        # Get a level-symmetric quadrature set for this order        
        self.quad_order = order
        self.generateQuadratureSet()

        # Pre-compute mu and eta fractions
        self.mus = 2. * self.quadrature_set['mu'] / delta
        self.etas = 2. * self.quadrature_set['eta'] / delta

        # Initialize mesh cell xs data and sources
        self.geometry.generateMeshStencil(self.num_mesh)
        self.mesh_stencil = self.geometry.getMeshtencil()
        self.initializeMeshCellSources()
        self.initializeMeshCellXSData()

        # Initialize angular and scalar flux arrays
        self.initializeAngularFluxes()
        self.initializeScalarFluxes()

        # Initialize the initial residual on the cell-avg scalar fluxes
        eps = numpy.inf

        # Loop over transport sweep until converged
        for i in range(max_iters):

            print 'Iteration %d with eps = %f' % (i, eps)
            
            # Plot the scalar flux from this iteration
            self.plotScalarFlux(iteration=i)
            
            # Zero out scalar flux each time
            self.scalar_flux.fill(0.)
            
            # Perform a transport sweep
            self.transportSweep()
            
            # Compute scalar flux from angular fluxes
            self.scalar_flux = (self.ang_flux * self.wgt).sum(axis=0).sum(axis=2)
            self
            self.computeScalarFlux()

            # Normalize the scalar flux to the average
            self.scalar_flux /= np.avg(self.scalar_flux.flatten())
            
            # Check for convergence
            eps = np.sqrt(np.sum((self.scalar_flux - self.old_scalar_flux)**2))
                          
            # If converged, break the loop
            if (eps < tol):
                break
            # Otherwise, store old scalar flux and repeat
            else:
                self.old_scalar_flux = np.copy(self.scalar_flux)

        print 'converged in %d iterations with eps = %f' % (i, eps)



    def transportSweep(self, reflect=True):

        quadrants = np.arange(4)

        for quad in quadrants:
            self.sweepQuadrant(quad, reflect)


    def sweepQuadrant(self, quad, reflect=True):

        if quad == 0:
            step_x = +1
            step_y = +1
            side_x = 0
            side_y = 1
            ang_offset = 0
        elif quad == 1:
            step_x = -1
            step_y = -1
            side_x = 2
            side_y = 3
            ang_offset = self.na/2
        elif quad == 2:
            step_x = -1
            step_y = +1
            side_x = 2
            side_y = 1
            ang_offset = self.na/4
        else:
            step_x = +1
            step_y = -1
            side_x = 0
            side_y = 3
            ang_offset = 3*self.na/4

        # Loop over mesh cells
        for y in self.mesh[::step_y]:
            for x in self.mesh[::step_x]:

                # Get the total xs and source for this mesh cell
                total_xs = self.total_xs[y][x]
                source = self.source[y][x]

                # Loop over angles for this mesh cell
                for ang in (range(na)+ang_offset):

                    # Get mu and eta for this angle
                    mu = self.mus[ang]
                    eta = self.etas[ang]

                    # Compute cell-averaged angular flux (diamond difference)
                    self.ang_flux[quad,y,x,ang] = source
                    self.ang_flux[quad,y,x,ang] += mu*self.wave[side_x,x,ang]
                    self.ang_flux[quad,y,x,ang] += eta*self.wave[side_y,y,ang]
                    self.ang_flux[quad,y,x,ang] /= (total_xs + mu + eta)

                    # Compute flux on right/left cell edge of next cell
                    self.wave[side_x,x,ang] = 2.*self.ang_flux[quad,y,x,ang] - \
                                                 self.wave[side_x,x,ang]

                    # Compute flux on top/bottom cell edge of next cell
                    self.wave[side_y,y,ang] = 2.*self.ang_flux[quad,y,x,ang] - \
                                                 self.wave[side_y,y,ang]

        # Reflective boundary conditions
        if reflect:
            for i in self.mesh:
                for ang in range(na):
                    self.ang_flux[side_x-2,i,ang] = self.ang_flux[side_x,i,ang]
                    self.ang_flux[side_y-2,i,ang] = self.ang_flux[side_y,i,ang]


    def plotScalarFlux(self, iteration):

        plt.figure()
        plt.pcolor(numpy.linspace(0, self.geometry.pitch, num_mesh+1),
                   numpy.linspace(0, self.geometry.pitch, num_mesh+1),
                   self.scalar_flux)        
        plt.axis([0, self.geometry.getPitch(), 0, self.geometry.getPitch()])
        plt.title('SN Pin Cell Flux (iteration ' + str(iteration)  +')')
        plt.savefig('flux-iter-' + str(iteration) + '.png')
